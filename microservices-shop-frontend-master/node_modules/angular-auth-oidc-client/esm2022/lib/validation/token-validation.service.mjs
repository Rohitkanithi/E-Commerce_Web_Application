import { inject, Injectable } from '@angular/core';
import { base64url } from 'rfc4648';
import { from, of } from 'rxjs';
import { map, mergeMap, tap } from 'rxjs/operators';
import { JwkExtractor } from '../extractors/jwk.extractor';
import { LoggerService } from '../logging/logger.service';
import { TokenHelperService } from '../utils/tokenHelper/token-helper.service';
import { JwkWindowCryptoService } from './jwk-window-crypto.service';
import { JwtWindowCryptoService } from './jwt-window-crypto.service';
import { alg2kty, getImportAlg, getVerifyAlg } from './token-validation.helper';
import * as i0 from "@angular/core";
// http://openid.net/specs/openid-connect-implicit-1_0.html
// id_token
// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)
// MUST exactly match the value of the iss (issuer) Claim.
//
// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified
// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,
// or if it contains additional audiences not trusted by the Client.
//
// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.
//
// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.
//
// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the
// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.
//
// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect
// Core 1.0
// [OpenID.Core] specification.
//
// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account
// for clock skew).
//
// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,
// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.
//
// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent
// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks
// is Client specific.
//
// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.
// The meaning and processing of acr Claim Values is out of scope for this document.
//
// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication
// if it determines too much time has elapsed since the last End- User authentication.
// Access Token Validation
// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]
// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.
// access_token C2: Take the left- most half of the hash and base64url- encode it.
// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present
// in the ID Token.
export class TokenValidationService {
    constructor() {
        this.keyAlgorithms = [
            'HS256',
            'HS384',
            'HS512',
            'RS256',
            'RS384',
            'RS512',
            'ES256',
            'ES384',
            'PS256',
            'PS384',
            'PS512',
        ];
        this.tokenHelperService = inject(TokenHelperService);
        this.loggerService = inject(LoggerService);
        this.jwkExtractor = inject(JwkExtractor);
        this.jwkWindowCryptoService = inject(JwkWindowCryptoService);
        this.jwtWindowCryptoService = inject(JwtWindowCryptoService);
    }
    static { this.refreshTokenNoncePlaceholder = '--RefreshToken--'; }
    // id_token C7: The current time MUST be before the time represented by the exp Claim
    // (possibly allowing for some small leeway to account for clock skew).
    hasIdTokenExpired(token, configuration, offsetSeconds) {
        const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configuration);
        return !this.validateIdTokenExpNotExpired(decoded, configuration, offsetSeconds);
    }
    // id_token C7: The current time MUST be before the time represented by the exp Claim
    // (possibly allowing for some small leeway to account for clock skew).
    validateIdTokenExpNotExpired(decodedIdToken, configuration, offsetSeconds) {
        const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);
        offsetSeconds = offsetSeconds || 0;
        if (!tokenExpirationDate) {
            return false;
        }
        const tokenExpirationValue = tokenExpirationDate.valueOf();
        const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);
        const tokenNotExpired = tokenExpirationValue > nowWithOffset;
        this.loggerService.logDebug(configuration, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);
        return tokenNotExpired;
    }
    validateAccessTokenNotExpired(accessTokenExpiresAt, configuration, offsetSeconds) {
        // value is optional, so if it does not exist, then it has not expired
        if (!accessTokenExpiresAt) {
            return true;
        }
        offsetSeconds = offsetSeconds || 0;
        const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();
        const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);
        const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;
        this.loggerService.logDebug(configuration, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);
        return tokenNotExpired;
    }
    // iss
    // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the
    // https scheme that contains scheme, host,
    // and optionally, port number and path components and no query or fragment components.
    //
    // sub
    // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,
    // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.
    // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.
    //
    // aud
    // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an
    // audience value.
    // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.
    // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.
    //
    // exp
    // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.
    // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.
    // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.
    // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until
    // the date/ time.
    // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.
    //
    // iat
    // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from
    // 1970- 01 - 01T00: 00: 00Z as measured
    // in UTC until the date/ time.
    validateRequiredIdToken(dataIdToken, configuration) {
        let validated = true;
        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iss')) {
            validated = false;
            this.loggerService.logWarning(configuration, 'iss is missing, this is required in the id_token');
        }
        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'sub')) {
            validated = false;
            this.loggerService.logWarning(configuration, 'sub is missing, this is required in the id_token');
        }
        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'aud')) {
            validated = false;
            this.loggerService.logWarning(configuration, 'aud is missing, this is required in the id_token');
        }
        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'exp')) {
            validated = false;
            this.loggerService.logWarning(configuration, 'exp is missing, this is required in the id_token');
        }
        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iat')) {
            validated = false;
            this.loggerService.logWarning(configuration, 'iat is missing, this is required in the id_token');
        }
        return validated;
    }
    // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,
    // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.
    validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configuration) {
        if (disableIatOffsetValidation) {
            return true;
        }
        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iat')) {
            return false;
        }
        const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch
        dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);
        maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;
        const nowInUtc = new Date(new Date().toUTCString());
        const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();
        const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;
        this.loggerService.logDebug(configuration, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);
        if (diff > 0) {
            return diff < maxOffsetAllowedInMilliseconds;
        }
        return -diff < maxOffsetAllowedInMilliseconds;
    }
    // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one
    // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.
    // The precise method for detecting replay attacks is Client specific.
    // However the nonce claim SHOULD not be present for the refresh_token grant type
    // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on
    // The current spec is ambiguous and KeyCloak does send it.
    validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configuration) {
        const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) &&
            localNonce === TokenValidationService.refreshTokenNoncePlaceholder;
        if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {
            this.loggerService.logDebug(configuration, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' +
                dataIdToken.nonce +
                ' local_nonce:' +
                localNonce);
            return false;
        }
        return true;
    }
    // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)
    // MUST exactly match the value of the iss (issuer) Claim.
    validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configuration) {
        if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {
            this.loggerService.logDebug(configuration, 'Validate_id_token_iss failed, dataIdToken.iss: ' +
                dataIdToken.iss +
                ' authWellKnownEndpoints issuer:' +
                authWellKnownEndpointsIssuer);
            return false;
        }
        return true;
    }
    // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified
    // by the iss (issuer) Claim as an audience.
    // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences
    // not trusted by the Client.
    validateIdTokenAud(dataIdToken, aud, configuration) {
        if (Array.isArray(dataIdToken.aud)) {
            const result = dataIdToken.aud.includes(aud);
            if (!result) {
                this.loggerService.logDebug(configuration, 'Validate_id_token_aud array failed, dataIdToken.aud: ' +
                    dataIdToken.aud +
                    ' client_id:' +
                    aud);
                return false;
            }
            return true;
        }
        else if (dataIdToken.aud !== aud) {
            this.loggerService.logDebug(configuration, 'Validate_id_token_aud failed, dataIdToken.aud: ' +
                dataIdToken.aud +
                ' client_id:' +
                aud);
            return false;
        }
        return true;
    }
    validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {
        if (!dataIdToken) {
            return false;
        }
        return !(Array.isArray(dataIdToken.aud) &&
            dataIdToken.aud.length > 1 &&
            !dataIdToken.azp);
    }
    // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.
    validateIdTokenAzpValid(dataIdToken, clientId) {
        if (!dataIdToken?.azp) {
            return true;
        }
        return dataIdToken.azp === clientId;
    }
    validateStateFromHashCallback(state, localState, configuration) {
        if (state !== localState) {
            this.loggerService.logDebug(configuration, 'ValidateStateFromHashCallback failed, state: ' +
                state +
                ' local_state:' +
                localState);
            return false;
        }
        return true;
    }
    // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg
    // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.
    // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the
    // OpenID Connect Core 1.0 [OpenID.Core] specification.
    validateSignatureIdToken(idToken, jwtkeys, configuration) {
        if (!idToken) {
            return of(true);
        }
        if (!jwtkeys || !jwtkeys.keys) {
            return of(false);
        }
        const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configuration);
        if (Object.keys(headerData).length === 0 &&
            headerData.constructor === Object) {
            this.loggerService.logWarning(configuration, 'id token has no header data');
            return of(false);
        }
        const kid = headerData.kid;
        const alg = headerData.alg;
        const keys = jwtkeys.keys;
        let foundKeys;
        let key;
        if (!this.keyAlgorithms.includes(alg)) {
            this.loggerService.logWarning(configuration, 'alg not supported', alg);
            return of(false);
        }
        const kty = alg2kty(alg);
        const use = 'sig';
        try {
            foundKeys = kid
                ? this.jwkExtractor.extractJwk(keys, { kid, kty, use }, false)
                : this.jwkExtractor.extractJwk(keys, { kty, use }, false);
            if (foundKeys.length === 0) {
                foundKeys = kid
                    ? this.jwkExtractor.extractJwk(keys, { kid, kty })
                    : this.jwkExtractor.extractJwk(keys, { kty });
            }
            key = foundKeys[0];
        }
        catch (e) {
            this.loggerService.logError(configuration, e);
            return of(false);
        }
        const algorithm = getImportAlg(alg);
        const signingInput = this.tokenHelperService.getSigningInputFromToken(idToken, true, configuration);
        const rawSignature = this.tokenHelperService.getSignatureFromToken(idToken, true, configuration);
        return from(this.jwkWindowCryptoService.importVerificationKey(key, algorithm)).pipe(mergeMap((cryptoKey) => {
            const signature = base64url.parse(rawSignature, {
                loose: true,
            });
            const verifyAlgorithm = getVerifyAlg(alg);
            return from(this.jwkWindowCryptoService.verifyKey(verifyAlgorithm, cryptoKey, signature, signingInput));
        }), tap((isValid) => {
            if (!isValid) {
                this.loggerService.logWarning(configuration, 'incorrect Signature, validation failed for id_token');
            }
        }));
    }
    // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'
    //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {
    ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);
    ////    if (!header_data.hasOwnProperty('kid')) {
    ////        // no kid defined in Jose header
    ////        if (jwtkeys.keys.length != 1) {
    ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');
    ////            return false;
    ////        }
    ////    }
    ////    return true;
    //// }
    // Access Token Validation
    // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]
    // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.
    // access_token C2: Take the left- most half of the hash and base64url- encode it.
    // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash
    // is present in the ID Token.
    validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configuration) {
        this.loggerService.logDebug(configuration, 'at_hash from the server:' + atHash);
        // 'sha256' 'sha384' 'sha512'
        let sha = 'SHA-256';
        if (idTokenAlg.includes('384')) {
            sha = 'SHA-384';
        }
        else if (idTokenAlg.includes('512')) {
            sha = 'SHA-512';
        }
        return this.jwtWindowCryptoService
            .generateAtHash('' + accessToken, sha)
            .pipe(mergeMap((hash) => {
            this.loggerService.logDebug(configuration, 'at_hash client validation not decoded:' + hash);
            if (hash === atHash) {
                return of(true); // isValid;
            }
            else {
                return this.jwtWindowCryptoService
                    .generateAtHash('' + decodeURIComponent(accessToken), sha)
                    .pipe(map((newHash) => {
                    this.loggerService.logDebug(configuration, '-gen access--' + hash);
                    return newHash === atHash;
                }));
            }
        }));
    }
    millisToMinutesAndSeconds(millis) {
        const minutes = Math.floor(millis / 60000);
        const seconds = ((millis % 60000) / 1000).toFixed(0);
        return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;
    }
    calculateNowWithOffset(offsetSeconds) {
        return new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: TokenValidationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: TokenValidationService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: TokenValidationService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW4tdmFsaWRhdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1hdXRoLW9pZGMtY2xpZW50L3NyYy9saWIvdmFsaWRhdGlvbi90b2tlbi12YWxpZGF0aW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUNwQyxPQUFPLEVBQUUsSUFBSSxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM1QyxPQUFPLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVwRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDM0QsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzFELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDJDQUEyQyxDQUFDO0FBQy9FLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3JFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3JFLE9BQU8sRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDOztBQUVoRiwyREFBMkQ7QUFFM0QsV0FBVztBQUNYLDRHQUE0RztBQUM1RywwREFBMEQ7QUFDMUQsRUFBRTtBQUNGLHVJQUF1STtBQUN2SSx1SUFBdUk7QUFDdkksb0VBQW9FO0FBQ3BFLEVBQUU7QUFDRixtSEFBbUg7QUFDbkgsRUFBRTtBQUNGLDhIQUE4SDtBQUM5SCxFQUFFO0FBQ0Ysa0lBQWtJO0FBQ2xJLCtGQUErRjtBQUMvRixFQUFFO0FBQ0YscUlBQXFJO0FBQ3JJLFdB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QU8sR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVyRCxPQUFPLE9BQU8sR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDO0lBQzlELENBQUM7SUFFTyxzQkFBc0IsQ0FBQyxhQUFxQjtRQUNsRCxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxhQUFhLEdBQUcsSUFBSSxDQUFDO0lBQzdFLENBQUM7OEdBcmlCVSxzQkFBc0I7a0hBQXRCLHNCQUFzQixjQURULE1BQU07OzJGQUNuQixzQkFBc0I7a0JBRGxDLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBiYXNlNjR1cmwgfSBmcm9tICdyZmM0NjQ4JztcbmltcG9ydCB7IGZyb20sIE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIG1lcmdlTWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBPcGVuSWRDb25maWd1cmF0aW9uIH0gZnJvbSAnLi4vY29uZmlnL29wZW5pZC1jb25maWd1cmF0aW9uJztcbmltcG9ydCB7IEp3a0V4dHJhY3RvciB9IGZyb20gJy4uL2V4dHJhY3RvcnMvandrLmV4dHJhY3Rvcic7XG5pbXBvcnQgeyBMb2dnZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbG9nZ2luZy9sb2dnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBUb2tlbkhlbHBlclNlcnZpY2UgfSBmcm9tICcuLi91dGlscy90b2tlbkhlbHBlci90b2tlbi1oZWxwZXIuc2VydmljZSc7XG5pbXBvcnQgeyBKd2tXaW5kb3dDcnlwdG9TZXJ2aWNlIH0gZnJvbSAnLi9qd2std2luZG93LWNyeXB0by5zZXJ2aWNlJztcbmltcG9ydCB7IEp3dFdpbmRvd0NyeXB0b1NlcnZpY2UgfSBmcm9tICcuL2p3dC13aW5kb3ctY3J5cHRvLnNlcnZpY2UnO1xuaW1wb3J0IHsgYWxnMmt0eSwgZ2V0SW1wb3J0QWxnLCBnZXRWZXJpZnlBbGcgfSBmcm9tICcuL3Rva2VuLXZhbGlkYXRpb24uaGVscGVyJztcblxuLy8gaHR0cDovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtaW1wbGljaXQtMV8wLmh0bWxcblxuLy8gaWRfdG9rZW5cbi8vIGlkX3Rva2VuIEMxOiBUaGUgSXNzdWVyIElkZW50aWZpZXIgZm9yIHRoZSBPcGVuSUQgUHJvdmlkZXIgKHdoaWNoIGlzIHR5cGljYWxseSBvYnRhaW5lZCBkdXJpbmcgRGlzY292ZXJ5KVxuLy8gTVVTVCBleGFjdGx5IG1hdGNoIHRoZSB2YWx1ZSBvZiB0aGUgaXNzIChpc3N1ZXIpIENsYWltLlxuLy9cbi8vIGlkX3Rva2VuIEMyOiBUaGUgQ2xpZW50IE1VU1QgdmFsaWRhdGUgdGhhdCB0aGUgYXVkIChhdWRpZW5jZSkgQ2xhaW0gY29udGFpbnMgaXRzIGNsaWVudF9pZCB2YWx1ZSByZWdpc3RlcmVkIGF0IHRoZSBJc3N1ZXIgaWRlbnRpZmllZFxuLy8gYnkgdGhlIGlzcyAoaXNzdWVyKSBDbGFpbSBhcyBhbiBhdWRpZW5jZS5UaGUgSUQgVG9rZW4gTVVTVCBiZSByZWplY3RlZCBpZiB0aGUgSUQgVG9rZW4gZG9lcyBub3QgbGlzdCB0aGUgQ2xpZW50IGFzIGEgdmFsaWQgYXVkaWVuY2UsXG4vLyBvciBpZiBpdCBjb250YWlucyBhZGRpdGlvbmFsIGF1ZGllbmNlcyBub3QgdHJ1c3RlZCBieSB0aGUgQ2xpZW50LlxuLy9cbi8vIGlkX3Rva2VuIEMzOiBJZiB0aGUgSUQgVG9rZW4gY29udGFpbnMgbXVsdGlwbGUgYXVkaWVuY2VzLCB0aGUgQ2xpZW50IFNIT1VMRCB2ZXJpZnkgdGhhdCBhbiBhenAgQ2xhaW0gaXMgcHJlc2VudC5cbi8vXG4vLyBpZF90b2tlbiBDNDogSWYgYW4gYXpwIChhdXRob3JpemVkIHBhcnR5KSBDbGFpbSBpcyBwcmVzZW50LCB0aGUgQ2xpZW50IFNIT1VMRCB2ZXJpZnkgdGhhdCBpdHMgY2xpZW50X2lkIGlzIHRoZSBDbGFpbSBWYWx1ZS5cbi8vXG4vLyBpZF90b2tlbiBDNTogVGhlIENsaWVudCBNVVNUIHZhbGlkYXRlIHRoZSBzaWduYXR1cmUgb2YgdGhlIElEIFRva2VuIGFjY29yZGluZyB0byBKV1MgW0pXU10gdXNpbmcgdGhlIGFsZ29yaXRobSBzcGVjaWZpZWQgaW4gdGhlXG4vLyBhbGcgSGVhZGVyIFBhcmFtZXRlciBvZiB0aGUgSk9TRSBIZWFkZXIuVGhlIENsaWVudCBNVVNUIHVzZSB0aGUga2V5cyBwcm92aWRlZCBieSB0aGUgSXNzdWVyLlxuLy9cbi8vIGlkX3Rva2VuIEM2OiBUaGUgYWxnIHZhbHVlIFNIT1VMRCBiZSBSUzI1Ni4gVmFsaWRhdGlvbiBvZiB0b2tlbnMgdXNpbmcgb3RoZXIgc2lnbmluZyBhbGdvcml0aG1zIGlzIGRlc2NyaWJlZCBpbiB0aGUgT3BlbklEIENvbm5lY3Rcbi8vIENvcmUgMS4wXG4vLyBbT3BlbklELkNvcmVdIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gaWRfdG9rZW4gQzc6IFRoZSBjdXJyZW50IHRpbWUgTVVTVCBiZSBiZWZvcmUgdGhlIHRpbWUgcmVwcmVzZW50ZWQgYnkgdGhlIGV4cCBDbGFpbSAocG9zc2libHkgYWxsb3dpbmcgZm9yIHNvbWUgc21hbGwgbGVld2F5IHRvIGFjY291bnRcbi8vIGZvciBjbG9jayBza2V3KS5cbi8vXG4vLyBpZF90b2tlbiBDODogVGhlIGlhdCBDbGFpbSBjYW4gYmUgdXNlZCB0byByZWplY3QgdG9rZW5zIHRoYXQgd2VyZSBpc3N1ZWQgdG9vIGZhciBhd2F5IGZyb20gdGhlIGN1cnJlbnQgdGltZSxcbi8vIGxpbWl0aW5nIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IG5vbmNlcyBuZWVkIHRvIGJlIHN0b3JlZCB0byBwcmV2ZW50IGF0dGFja3MuVGhlIGFjY2VwdGFibGUgcmFuZ2UgaXMgQ2xpZW50IHNwZWNpZmljLlxuLy9cbi8vIGlkX3Rva2VuIEM5OiBUaGUgdmFsdWUgb2YgdGhlIG5vbmNlIENsYWltIE1VU1QgYmUgY2hlY2tlZCB0byB2ZXJpZnkgdGhhdCBpdCBpcyB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgb25lIHRoYXQgd2FzIHNlbnRcbi8vIGluIHRoZSBBdXRoZW50aWNhdGlvbiBSZXF1ZXN0LlRoZSBDbGllbnQgU0hPVUxEIGNoZWNrIHRoZSBub25jZSB2YWx1ZSBmb3IgcmVwbGF5IGF0dGFja3MuVGhlIHByZWNpc2UgbWV0aG9kIGZvciBkZXRlY3RpbmcgcmVwbGF5IGF0dGFja3Ncbi8vIGlzIENsaWVudCBzcGVjaWZpYy5cbi8vXG4vLyBpZF90b2tlbiBDMTA6IElmIHRoZSBhY3IgQ2xhaW0gd2FzIHJlcXVlc3RlZCwgdGhlIENsaWVudCBTSE9VTEQgY2hlY2sgdGhhdCB0aGUgYXNzZXJ0ZWQgQ2xhaW0gVmFsdWUgaXMgYXBwcm9wcmlhdGUuXG4vLyBUaGUgbWVhbmluZyBhbmQgcHJvY2Vzc2luZyBvZiBhY3IgQ2xhaW0gVmFsdWVzIGlzIG91dCBvZiBzY29wZSBmb3IgdGhpcyBkb2N1bWVudC5cbi8vXG4vLyBpZF90b2tlbiBDMTE6IFdoZW4gYSBtYXhfYWdlIHJlcXVlc3QgaXMgbWFkZSwgdGhlIENsaWVudCBTSE9VTEQgY2hlY2sgdGhlIGF1dGhfdGltZSBDbGFpbSB2YWx1ZSBhbmQgcmVxdWVzdCByZS0gYXV0aGVudGljYXRpb25cbi8vIGlmIGl0IGRldGVybWluZXMgdG9vIG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBFbmQtIFVzZXIgYXV0aGVudGljYXRpb24uXG5cbi8vIEFjY2VzcyBUb2tlbiBWYWxpZGF0aW9uXG4vLyBhY2Nlc3NfdG9rZW4gQzE6IEhhc2ggdGhlIG9jdGV0cyBvZiB0aGUgQVNDSUkgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFjY2Vzc190b2tlbiB3aXRoIHRoZSBoYXNoIGFsZ29yaXRobSBzcGVjaWZpZWQgaW4gSldBW0pXQV1cbi8vIGZvciB0aGUgYWxnIEhlYWRlciBQYXJhbWV0ZXIgb2YgdGhlIElEIFRva2VuJ3MgSk9TRSBIZWFkZXIuIEZvciBpbnN0YW5jZSwgaWYgdGhlIGFsZyBpcyBSUzI1NiwgdGhlIGhhc2ggYWxnb3JpdGhtIHVzZWQgaXMgU0hBLTI1Ni5cbi8vIGFjY2Vzc190b2tlbiBDMjogVGFrZSB0aGUgbGVmdC0gbW9zdCBoYWxmIG9mIHRoZSBoYXNoIGFuZCBiYXNlNjR1cmwtIGVuY29kZSBpdC5cbi8vIGFjY2Vzc190b2tlbiBDMzogVGhlIHZhbHVlIG9mIGF0X2hhc2ggaW4gdGhlIElEIFRva2VuIE1VU1QgbWF0Y2ggdGhlIHZhbHVlIHByb2R1Y2VkIGluIHRoZSBwcmV2aW91cyBzdGVwIGlmIGF0X2hhc2ggaXMgcHJlc2VudFxuLy8gaW4gdGhlIElEIFRva2VuLlxuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIFRva2VuVmFsaWRhdGlvblNlcnZpY2Uge1xuICBzdGF0aWMgcmVmcmVzaFRva2VuTm9uY2VQbGFjZWhvbGRlciA9ICctLVJlZnJlc2hUb2tlbi0tJztcblxuICBrZXlBbGdvcml0aG1zOiBzdHJpbmdbXSA9IFtcbiAgICAnSFMyNTYnLFxuICAgICdIUzM4NCcsXG4gICAgJ0hTNTEyJyxcbiAgICAnUlMyNTYnLFxuICAgICdSUzM4NCcsXG4gICAgJ1JTNTEyJyxcbiAgICAnRVMyNTYnLFxuICAgICdFUzM4NCcsXG4gICAgJ1BTMjU2JyxcbiAgICAnUFMzODQnLFxuICAgICdQUzUxMicsXG4gIF07XG5cbiAgcHJpdmF0ZSByZWFkb25seSB0b2tlbkhlbHBlclNlcnZpY2UgPSBpbmplY3QoVG9rZW5IZWxwZXJTZXJ2aWNlKTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlclNlcnZpY2UgPSBpbmplY3QoTG9nZ2VyU2VydmljZSk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBqd2tFeHRyYWN0b3IgPSBpbmplY3QoSndrRXh0cmFjdG9yKTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGp3a1dpbmRvd0NyeXB0b1NlcnZpY2UgPSBpbmplY3QoSndrV2luZG93Q3J5cHRvU2VydmljZSk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBqd3RXaW5kb3dDcnlwdG9TZXJ2aWNlID0gaW5qZWN0KEp3dFdpbmRvd0NyeXB0b1NlcnZpY2UpO1xuXG4gIC8vIGlkX3Rva2VuIEM3OiBUaGUgY3VycmVudCB0aW1lIE1VU1QgYmUgYmVmb3JlIHRoZSB0aW1lIHJlcHJlc2VudGVkIGJ5IHRoZSBleHAgQ2xhaW1cbiAgLy8gKHBvc3NpYmx5IGFsbG93aW5nIGZvciBzb21lIHNtYWxsIGxlZXdheSB0byBhY2NvdW50IGZvciBjbG9jayBza2V3KS5cbiAgaGFzSWRUb2tlbkV4cGlyZWQoXG4gICAgdG9rZW46IHN0cmluZyxcbiAgICBjb25maWd1cmF0aW9uOiBPcGVuSWRDb25maWd1cmF0aW9uLFxuICAgIG9mZnNldFNlY29uZHM/OiBudW1iZXJcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZGVjb2RlZCA9IHRoaXMudG9rZW5IZWxwZXJTZXJ2aWNlLmdldFBheWxvYWRGcm9tVG9rZW4oXG4gICAgICB0b2tlbixcbiAgICAgIGZhbHNlLFxuICAgICAgY29uZmlndXJhdGlvblxuICAgICk7XG5cbiAgICByZXR1cm4gIXRoaXMudmFsaWRhdGVJZFRva2VuRXhwTm90RXhwaXJlZChcbiAgICAgIGRlY29kZWQsXG4gICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgb2Zmc2V0U2Vjb25kc1xuICAgICk7XG4gIH1cblxuICAvLyBpZF90b2tlbiBDNzogVGhlIGN1cnJlbnQgdGltZSBNVVNUIGJlIGJlZm9yZSB0aGUgdGltZSByZXByZXNlbnRlZCBieSB0aGUgZXhwIENsYWltXG4gIC8vIChwb3NzaWJseSBhbGxvd2luZyBmb3Igc29tZSBzbWFsbCBsZWV3YXkgdG8gYWNjb3VudCBmb3IgY2xvY2sgc2tldykuXG4gIHZhbGlkYXRlSWRUb2tlbkV4cE5vdEV4cGlyZWQoXG4gICAgZGVjb2RlZElkVG9rZW46IHN0cmluZyxcbiAgICBjb25maWd1cmF0aW9uOiBPcGVuSWRDb25maWd1cmF0aW9uLFxuICAgIG9mZnNldFNlY29uZHM/OiBudW1iZXJcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdG9rZW5FeHBpcmF0aW9uRGF0ZSA9XG4gICAgICB0aGlzLnRva2VuSGVscGVyU2VydmljZS5nZXRUb2tlbkV4cGlyYXRpb25EYXRlKGRlY29kZWRJZFRva2VuKTtcblxuICAgIG9mZnNldFNlY29uZHMgPSBvZmZzZXRTZWNvbmRzIHx8IDA7XG5cbiAgICBpZiAoIXRva2VuRXhwaXJhdGlvbkRhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbkV4cGlyYXRpb25WYWx1ZSA9IHRva2VuRXhwaXJhdGlvbkRhdGUudmFsdWVPZigpO1xuICAgIGNvbnN0IG5vd1dpdGhPZmZzZXQgPSB0aGlzLmNhbGN1bGF0ZU5vd1dpdGhPZmZzZXQob2Zmc2V0U2Vjb25kcyk7XG4gICAgY29uc3QgdG9rZW5Ob3RFeHBpcmVkID0gdG9rZW5FeHBpcmF0aW9uVmFsdWUgPiBub3dXaXRoT2Zmc2V0O1xuXG4gICAgdGhpcy5sb2dnZXJTZXJ2aWNlLmxvZ0RlYnVnKFxuICAgICAgY29uZmlndXJhdGlvbixcbiAgICAgIGBIYXMgaWRUb2tlbiBleHBpcmVkOiAkeyF0b2tlbk5vdEV4cGlyZWR9IC0tPiBleHBpcmVzIGluICR7dGhpcy5taWxsaXNUb01pbnV0ZXNBbmRTZWNvbmRzKFxuICAgICAgICB0b2tlbkV4cGlyYXRpb25WYWx1ZSAtIG5vd1dpdGhPZmZzZXRcbiAgICAgICl9ICwgJHtuZXcgRGF0ZSh0b2tlbkV4cGlyYXRpb25WYWx1ZSkudG9Mb2NhbGVUaW1lU3RyaW5nKCl9ID4gJHtuZXcgRGF0ZShcbiAgICAgICAgbm93V2l0aE9mZnNldFxuICAgICAgKS50b0xvY2FsZVRpbWVTdHJpbmcoKX1gXG4gICAgKTtcblxuICAgIHJldHVybiB0b2tlbk5vdEV4cGlyZWQ7XG4gIH1cblxuICB2YWxpZGF0ZUFjY2Vzc1Rva2VuTm90RXhwaXJlZChcbiAgICBhY2Nlc3NUb2tlbkV4cGlyZXNBdDogRGF0ZSxcbiAgICBjb25maWd1cmF0aW9uOiBPcGVuSWRDb25maWd1cmF0aW9uLFxuICAgIG9mZnNldFNlY29uZHM/OiBudW1iZXJcbiAgKTogYm9vbGVhbiB7XG4gICAgLy8gdmFsdWUgaXMgb3B0aW9uYWwsIHNvIGlmIGl0IGRvZXMgbm90IGV4aXN0LCB0aGVuIGl0IGhhcyBub3QgZXhwaXJlZFxuICAgIGlmICghYWNjZXNzVG9rZW5FeHBpcmVzQXQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG9mZnNldFNlY29uZHMgPSBvZmZzZXRTZWNvbmRzIHx8IDA7XG4gICAgY29uc3QgYWNjZXNzVG9rZW5FeHBpcmF0aW9uVmFsdWUgPSBhY2Nlc3NUb2tlbkV4cGlyZXNBdC52YWx1ZU9mKCk7XG4gICAgY29uc3Qgbm93V2l0aE9mZnNldCA9IHRoaXMuY2FsY3VsYXRlTm93V2l0aE9mZnNldChvZmZzZXRTZWNvbmRzKTtcbiAgICBjb25zdCB0b2tlbk5vdEV4cGlyZWQgPSBhY2Nlc3NUb2tlbkV4cGlyYXRpb25WYWx1ZSA+IG5vd1dpdGhPZmZzZXQ7XG5cbiAgICB0aGlzLmxvZ2dlclNlcnZpY2UubG9nRGVidWcoXG4gICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgYEhhcyBhY2Nlc3NUb2tlbiBleHBpcmVkOiAkeyF0b2tlbk5vdEV4cGlyZWR9IC0tPiBleHBpcmVzIGluICR7dGhpcy5taWxsaXNUb01pbnV0ZXNBbmRTZWNvbmRzKFxuICAgICAgICBhY2Nlc3NUb2tlbkV4cGlyYXRpb25WYWx1ZSAtIG5vd1dpdGhPZmZzZXRcbiAgICAgICl9ICwgJHtuZXcgRGF0ZShcbiAgICAgICAgYWNjZXNzVG9rZW5FeHBpcmF0aW9uVmFsdWVcbiAgICAgICkudG9Mb2NhbGVUaW1lU3RyaW5nKCl9ID4gJHtuZXcgRGF0ZShub3dXaXRoT2Zmc2V0KS50b0xvY2FsZVRpbWVTdHJpbmcoKX1gXG4gICAgKTtcblxuICAgIHJldHVybiB0b2tlbk5vdEV4cGlyZWQ7XG4gIH1cblxuICAvLyBpc3NcbiAgLy8gUkVRVUlSRUQuIElzc3VlciBJZGVudGlmaWVyIGZvciB0aGUgSXNzdWVyIG9mIHRoZSByZXNwb25zZS5UaGUgaXNzIHZhbHVlIGlzIGEgY2FzZS1zZW5zaXRpdmUgVVJMIHVzaW5nIHRoZVxuICAvLyBodHRwcyBzY2hlbWUgdGhhdCBjb250YWlucyBzY2hlbWUsIGhvc3QsXG4gIC8vIGFuZCBvcHRpb25hbGx5LCBwb3J0IG51bWJlciBhbmQgcGF0aCBjb21wb25lbnRzIGFuZCBubyBxdWVyeSBvciBmcmFnbWVudCBjb21wb25lbnRzLlxuICAvL1xuICAvLyBzdWJcbiAgLy8gUkVRVUlSRUQuIFN1YmplY3QgSWRlbnRpZmllci5Mb2NhbGx5IHVuaXF1ZSBhbmQgbmV2ZXIgcmVhc3NpZ25lZCBpZGVudGlmaWVyIHdpdGhpbiB0aGUgSXNzdWVyIGZvciB0aGUgRW5kLSBVc2VyLFxuICAvLyB3aGljaCBpcyBpbnRlbmRlZCB0byBiZSBjb25zdW1lZCBieSB0aGUgQ2xpZW50LCBlLmcuLCAyNDQwMDMyMCBvciBBSXRPYXdtd3RXd2NUMGs1MUJheWV3TnZ1dHJKVXFzdmw2cXM3QTQuXG4gIC8vIEl0IE1VU1QgTk9UIGV4Y2VlZCAyNTUgQVNDSUkgY2hhcmFjdGVycyBpbiBsZW5ndGguVGhlIHN1YiB2YWx1ZSBpcyBhIGNhc2Utc2Vuc2l0aXZlIHN0cmluZy5cbiAgLy9cbiAgLy8gYXVkXG4gIC8vIFJFUVVJUkVELiBBdWRpZW5jZShzKSB0aGF0IHRoaXMgSUQgVG9rZW4gaXMgaW50ZW5kZWQgZm9yLiBJdCBNVVNUIGNvbnRhaW4gdGhlIE9BdXRoIDIuMCBjbGllbnRfaWQgb2YgdGhlIFJlbHlpbmcgUGFydHkgYXMgYW5cbiAgLy8gYXVkaWVuY2UgdmFsdWUuXG4gIC8vIEl0IE1BWSBhbHNvIGNvbnRhaW4gaWRlbnRpZmllcnMgZm9yIG90aGVyIGF1ZGllbmNlcy5JbiB0aGUgZ2VuZXJhbCBjYXNlLCB0aGUgYXVkIHZhbHVlIGlzIGFuIGFycmF5IG9mIGNhc2Utc2Vuc2l0aXZlIHN0cmluZ3MuXG4gIC8vIEluIHRoZSBjb21tb24gc3BlY2lhbCBjYXNlIHdoZW4gdGhlcmUgaXMgb25lIGF1ZGllbmNlLCB0aGUgYXVkIHZhbHVlIE1BWSBiZSBhIHNpbmdsZSBjYXNlLXNlbnNpdGl2ZSBzdHJpbmcuXG4gIC8vXG4gIC8vIGV4cFxuICAvLyBSRVFVSVJFRC4gRXhwaXJhdGlvbiB0aW1lIG9uIG9yIGFmdGVyIHdoaWNoIHRoZSBJRCBUb2tlbiBNVVNUIE5PVCBiZSBhY2NlcHRlZCBmb3IgcHJvY2Vzc2luZy5cbiAgLy8gVGhlIHByb2Nlc3Npbmcgb2YgdGhpcyBwYXJhbWV0ZXIgcmVxdWlyZXMgdGhhdCB0aGUgY3VycmVudCBkYXRlLyB0aW1lIE1VU1QgYmUgYmVmb3JlIHRoZSBleHBpcmF0aW9uIGRhdGUvIHRpbWUgbGlzdGVkIGluIHRoZSB2YWx1ZS5cbiAgLy8gSW1wbGVtZW50ZXJzIE1BWSBwcm92aWRlIGZvciBzb21lIHNtYWxsIGxlZXdheSwgdXN1YWxseSBubyBtb3JlIHRoYW4gYSBmZXcgbWludXRlcywgdG8gYWNjb3VudCBmb3IgY2xvY2sgc2tldy5cbiAgLy8gSXRzIHZhbHVlIGlzIGEgSlNPTiBbUkZDNzE1OV0gbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgZnJvbSAxOTcwLSAwMSAtIDAxVDAwOiAwMDowMFogYXMgbWVhc3VyZWQgaW4gVVRDIHVudGlsXG4gIC8vIHRoZSBkYXRlLyB0aW1lLlxuICAvLyBTZWUgUkZDIDMzMzkgW1JGQzMzMzldIGZvciBkZXRhaWxzIHJlZ2FyZGluZyBkYXRlLyB0aW1lcyBpbiBnZW5lcmFsIGFuZCBVVEMgaW4gcGFydGljdWxhci5cbiAgLy9cbiAgLy8gaWF0XG4gIC8vIFJFUVVJUkVELiBUaW1lIGF0IHdoaWNoIHRoZSBKV1Qgd2FzIGlzc3VlZC4gSXRzIHZhbHVlIGlzIGEgSlNPTiBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBmcm9tXG4gIC8vIDE5NzAtIDAxIC0gMDFUMDA6IDAwOiAwMFogYXMgbWVhc3VyZWRcbiAgLy8gaW4gVVRDIHVudGlsIHRoZSBkYXRlLyB0aW1lLlxuICB2YWxpZGF0ZVJlcXVpcmVkSWRUb2tlbihcbiAgICBkYXRhSWRUb2tlbjogYW55LFxuICAgIGNvbmZpZ3VyYXRpb246IE9wZW5JZENvbmZpZ3VyYXRpb25cbiAgKTogYm9vbGVhbiB7XG4gICAgbGV0IHZhbGlkYXRlZCA9IHRydWU7XG5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhSWRUb2tlbiwgJ2lzcycpKSB7XG4gICAgICB2YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nZ2VyU2VydmljZS5sb2dXYXJuaW5nKFxuICAgICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgICAnaXNzIGlzIG1pc3NpbmcsIHRoaXMgaXMgcmVxdWlyZWQgaW4gdGhlIGlkX3Rva2VuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhSWRUb2tlbiwgJ3N1YicpKSB7XG4gICAgICB2YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nZ2VyU2VydmljZS5sb2dXYXJuaW5nKFxuICAgICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgICAnc3ViIGlzIG1pc3NpbmcsIHRoaXMgaXMgcmVxdWlyZWQgaW4gdGhlIGlkX3Rva2VuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhSWRUb2tlbiwgJ2F1ZCcpKSB7XG4gICAgICB2YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nZ2VyU2VydmljZS5sb2dXYXJuaW5nKFxuICAgICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgICAnYXVkIGlzIG1pc3NpbmcsIHRoaXMgaXMgcmVxdWlyZWQgaW4gdGhlIGlkX3Rva2VuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhSWRUb2tlbiwgJ2V4cCcpKSB7XG4gICAgICB2YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nZ2VyU2VydmljZS5sb2dXYXJuaW5nKFxuICAgICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgICAnZXhwIGlzIG1pc3NpbmcsIHRoaXMgaXMgcmVxdWlyZWQgaW4gdGhlIGlkX3Rva2VuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhSWRUb2tlbiwgJ2lhdCcpKSB7XG4gICAgICB2YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nZ2VyU2VydmljZS5sb2dXYXJuaW5nKFxuICAgICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgICAnaWF0IGlzIG1pc3NpbmcsIHRoaXMgaXMgcmVxdWlyZWQgaW4gdGhlIGlkX3Rva2VuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVkO1xuICB9XG5cbiAgLy8gaWRfdG9rZW4gQzg6IFRoZSBpYXQgQ2xhaW0gY2FuIGJlIHVzZWQgdG8gcmVqZWN0IHRva2VucyB0aGF0IHdlcmUgaXNzdWVkIHRvbyBmYXIgYXdheSBmcm9tIHRoZSBjdXJyZW50IHRpbWUsXG4gIC8vIGxpbWl0aW5nIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IG5vbmNlcyBuZWVkIHRvIGJlIHN0b3JlZCB0byBwcmV2ZW50IGF0dGFja3MuVGhlIGFjY2VwdGFibGUgcmFuZ2UgaXMgQ2xpZW50IHNwZWNpZmljLlxuICB2YWxpZGF0ZUlkVG9rZW5JYXRNYXhPZmZzZXQoXG4gICAgZGF0YUlkVG9rZW46IGFueSxcbiAgICBtYXhPZmZzZXRBbGxvd2VkSW5TZWNvbmRzOiBudW1iZXIsXG4gICAgZGlzYWJsZUlhdE9mZnNldFZhbGlkYXRpb246IGJvb2xlYW4sXG4gICAgY29uZmlndXJhdGlvbjogT3BlbklkQ29uZmlndXJhdGlvblxuICApOiBib29sZWFuIHtcbiAgICBpZiAoZGlzYWJsZUlhdE9mZnNldFZhbGlkYXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFJZFRva2VuLCAnaWF0JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRlVGltZUlhdElkVG9rZW4gPSBuZXcgRGF0ZSgwKTsgLy8gVGhlIDAgaGVyZSBpcyB0aGUga2V5LCB3aGljaCBzZXRzIHRoZSBkYXRlIHRvIHRoZSBlcG9jaFxuXG4gICAgZGF0ZVRpbWVJYXRJZFRva2VuLnNldFVUQ1NlY29uZHMoZGF0YUlkVG9rZW4uaWF0KTtcbiAgICBtYXhPZmZzZXRBbGxvd2VkSW5TZWNvbmRzID0gbWF4T2Zmc2V0QWxsb3dlZEluU2Vjb25kcyB8fCAwO1xuXG4gICAgY29uc3Qgbm93SW5VdGMgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLnRvVVRDU3RyaW5nKCkpO1xuICAgIGNvbnN0IGRpZmYgPSBub3dJblV0Yy52YWx1ZU9mKCkgLSBkYXRlVGltZUlhdElkVG9rZW4udmFsdWVPZigpO1xuICAgIGNvbnN0IG1heE9mZnNldEFsbG93ZWRJbk1pbGxpc2Vjb25kcyA9IG1heE9mZnNldEFsbG93ZWRJblNlY29uZHMgKiAxMDAwO1xuXG4gICAgdGhpcy5sb2dnZXJTZXJ2aWNlLmxvZ0RlYnVnKFxuICAgICAgY29uZmlndXJhdGlvbixcbiAgICAgIGB2YWxpZGF0ZSBpZCB0b2tlbiBpYXQgbWF4IG9mZnNldCAke2RpZmZ9IDwgJHttYXhPZmZzZXRBbGxvd2VkSW5NaWxsaXNlY29uZHN9YFxuICAgICk7XG5cbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgIHJldHVybiBkaWZmIDwgbWF4T2Zmc2V0QWxsb3dlZEluTWlsbGlzZWNvbmRzO1xuICAgIH1cblxuICAgIHJldHVybiAtZGlmZiA8IG1heE9mZnNldEFsbG93ZWRJbk1pbGxpc2Vjb25kcztcbiAgfVxuXG4gIC8vIGlkX3Rva2VuIEM5OiBUaGUgdmFsdWUgb2YgdGhlIG5vbmNlIENsYWltIE1VU1QgYmUgY2hlY2tlZCB0byB2ZXJpZnkgdGhhdCBpdCBpcyB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgb25lXG4gIC8vIHRoYXQgd2FzIHNlbnQgaW4gdGhlIEF1dGhlbnRpY2F0aW9uIFJlcXVlc3QuVGhlIENsaWVudCBTSE9VTEQgY2hlY2sgdGhlIG5vbmNlIHZhbHVlIGZvciByZXBsYXkgYXR0YWNrcy5cbiAgLy8gVGhlIHByZWNpc2UgbWV0aG9kIGZvciBkZXRlY3RpbmcgcmVwbGF5IGF0dGFja3MgaXMgQ2xpZW50IHNwZWNpZmljLlxuXG4gIC8vIEhvd2V2ZXIgdGhlIG5vbmNlIGNsYWltIFNIT1VMRCBub3QgYmUgcHJlc2VudCBmb3IgdGhlIHJlZnJlc2hfdG9rZW4gZ3JhbnQgdHlwZVxuICAvLyBodHRwczovL2JpdGJ1Y2tldC5vcmcvb3BlbmlkL2Nvbm5lY3QvaXNzdWVzLzEwMjUvYW1iaWd1aXR5LXdpdGgtaG93LW5vbmNlLWlzLWhhbmRsZWQtb25cbiAgLy8gVGhlIGN1cnJlbnQgc3BlYyBpcyBhbWJpZ3VvdXMgYW5kIEtleUNsb2FrIGRvZXMgc2VuZCBpdC5cbiAgdmFsaWRhdGVJZFRva2VuTm9uY2UoXG4gICAgZGF0YUlkVG9rZW46IGFueSxcbiAgICBsb2NhbE5vbmNlOiBhbnksXG4gICAgaWdub3JlTm9uY2VBZnRlclJlZnJlc2g6IGJvb2xlYW4sXG4gICAgY29uZmlndXJhdGlvbjogT3BlbklkQ29uZmlndXJhdGlvblxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBpc0Zyb21SZWZyZXNoVG9rZW4gPVxuICAgICAgKGRhdGFJZFRva2VuLm5vbmNlID09PSB1bmRlZmluZWQgfHwgaWdub3JlTm9uY2VBZnRlclJlZnJlc2gpICYmXG4gICAgICBsb2NhbE5vbmNlID09PSBUb2tlblZhbGlkYXRpb25TZXJ2aWNlLnJlZnJlc2hUb2tlbk5vbmNlUGxhY2Vob2xkZXI7XG5cbiAgICBpZiAoIWlzRnJvbVJlZnJlc2hUb2tlbiAmJiBkYXRhSWRUb2tlbi5ub25jZSAhPT0gbG9jYWxOb25jZSkge1xuICAgICAgdGhpcy5sb2dnZXJTZXJ2aWNlLmxvZ0RlYnVnKFxuICAgICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgICAnVmFsaWRhdGVfaWRfdG9rZW5fbm9uY2UgZmFpbGVkLCBkYXRhSWRUb2tlbi5ub25jZTogJyArXG4gICAgICAgICAgZGF0YUlkVG9rZW4ubm9uY2UgK1xuICAgICAgICAgICcgbG9jYWxfbm9uY2U6JyArXG4gICAgICAgICAgbG9jYWxOb25jZVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaWRfdG9rZW4gQzE6IFRoZSBJc3N1ZXIgSWRlbnRpZmllciBmb3IgdGhlIE9wZW5JRCBQcm92aWRlciAod2hpY2ggaXMgdHlwaWNhbGx5IG9idGFpbmVkIGR1cmluZyBEaXNjb3ZlcnkpXG4gIC8vIE1VU1QgZXhhY3RseSBtYXRjaCB0aGUgdmFsdWUgb2YgdGhlIGlzcyAoaXNzdWVyKSBDbGFpbS5cbiAgdmFsaWRhdGVJZFRva2VuSXNzKFxuICAgIGRhdGFJZFRva2VuOiBhbnksXG4gICAgYXV0aFdlbGxLbm93bkVuZHBvaW50c0lzc3VlcjogYW55LFxuICAgIGNvbmZpZ3VyYXRpb246IE9wZW5JZENvbmZpZ3VyYXRpb25cbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKFxuICAgICAgKGRhdGFJZFRva2VuLmlzcyBhcyBzdHJpbmcpICE9PSAoYXV0aFdlbGxLbm93bkVuZHBvaW50c0lzc3VlciBhcyBzdHJpbmcpXG4gICAgKSB7XG4gICAgICB0aGlzLmxvZ2dlclNlcnZpY2UubG9nRGVidWcoXG4gICAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICAgICdWYWxpZGF0ZV9pZF90b2tlbl9pc3MgZmFpbGVkLCBkYXRhSWRUb2tlbi5pc3M6ICcgK1xuICAgICAgICAgIGRhdGFJZFRva2VuLmlzcyArXG4gICAgICAgICAgJyBhdXRoV2VsbEtub3duRW5kcG9pbnRzIGlzc3VlcjonICtcbiAgICAgICAgICBhdXRoV2VsbEtub3duRW5kcG9pbnRzSXNzdWVyXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpZF90b2tlbiBDMjogVGhlIENsaWVudCBNVVNUIHZhbGlkYXRlIHRoYXQgdGhlIGF1ZCAoYXVkaWVuY2UpIENsYWltIGNvbnRhaW5zIGl0cyBjbGllbnRfaWQgdmFsdWUgcmVnaXN0ZXJlZCBhdCB0aGUgSXNzdWVyIGlkZW50aWZpZWRcbiAgLy8gYnkgdGhlIGlzcyAoaXNzdWVyKSBDbGFpbSBhcyBhbiBhdWRpZW5jZS5cbiAgLy8gVGhlIElEIFRva2VuIE1VU1QgYmUgcmVqZWN0ZWQgaWYgdGhlIElEIFRva2VuIGRvZXMgbm90IGxpc3QgdGhlIENsaWVudCBhcyBhIHZhbGlkIGF1ZGllbmNlLCBvciBpZiBpdCBjb250YWlucyBhZGRpdGlvbmFsIGF1ZGllbmNlc1xuICAvLyBub3QgdHJ1c3RlZCBieSB0aGUgQ2xpZW50LlxuICB2YWxpZGF0ZUlkVG9rZW5BdWQoXG4gICAgZGF0YUlkVG9rZW46IGFueSxcbiAgICBhdWQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBjb25maWd1cmF0aW9uOiBPcGVuSWRDb25maWd1cmF0aW9uXG4gICk6IGJvb2xlYW4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFJZFRva2VuLmF1ZCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRhdGFJZFRva2VuLmF1ZC5pbmNsdWRlcyhhdWQpO1xuXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICB0aGlzLmxvZ2dlclNlcnZpY2UubG9nRGVidWcoXG4gICAgICAgICAgY29uZmlndXJhdGlvbixcbiAgICAgICAgICAnVmFsaWRhdGVfaWRfdG9rZW5fYXVkIGFycmF5IGZhaWxlZCwgZGF0YUlkVG9rZW4uYXVkOiAnICtcbiAgICAgICAgICAgIGRhdGFJZFRva2VuLmF1ZCArXG4gICAgICAgICAgICAnIGNsaWVudF9pZDonICtcbiAgICAgICAgICAgIGF1ZFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhSWRUb2tlbi5hdWQgIT09IGF1ZCkge1xuICAgICAgdGhpcy5sb2dnZXJTZXJ2aWNlLmxvZ0RlYnVnKFxuICAgICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgICAnVmFsaWRhdGVfaWRfdG9rZW5fYXVkIGZhaWxlZCwgZGF0YUlkVG9rZW4uYXVkOiAnICtcbiAgICAgICAgICBkYXRhSWRUb2tlbi5hdWQgK1xuICAgICAgICAgICcgY2xpZW50X2lkOicgK1xuICAgICAgICAgIGF1ZFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFsaWRhdGVJZFRva2VuQXpwRXhpc3RzSWZNb3JlVGhhbk9uZUF1ZChkYXRhSWRUb2tlbjogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKCFkYXRhSWRUb2tlbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhKFxuICAgICAgQXJyYXkuaXNBcnJheShkYXRhSWRUb2tlbi5hdWQpICYmXG4gICAgICBkYXRhSWRUb2tlbi5hdWQubGVuZ3RoID4gMSAmJlxuICAgICAgIWRhdGFJZFRva2VuLmF6cFxuICAgICk7XG4gIH1cblxuICAvLyBJZiBhbiBhenAgKGF1dGhvcml6ZWQgcGFydHkpIENsYWltIGlzIHByZXNlbnQsIHRoZSBDbGllbnQgU0hPVUxEIHZlcmlmeSB0aGF0IGl0cyBjbGllbnRfaWQgaXMgdGhlIENsYWltIFZhbHVlLlxuICB2YWxpZGF0ZUlkVG9rZW5BenBWYWxpZChcbiAgICBkYXRhSWRUb2tlbjogYW55LFxuICAgIGNsaWVudElkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKCFkYXRhSWRUb2tlbj8uYXpwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YUlkVG9rZW4uYXpwID09PSBjbGllbnRJZDtcbiAgfVxuXG4gIHZhbGlkYXRlU3RhdGVGcm9tSGFzaENhbGxiYWNrKFxuICAgIHN0YXRlOiBhbnksXG4gICAgbG9jYWxTdGF0ZTogYW55LFxuICAgIGNvbmZpZ3VyYXRpb246IE9wZW5JZENvbmZpZ3VyYXRpb25cbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKChzdGF0ZSBhcyBzdHJpbmcpICE9PSAobG9jYWxTdGF0ZSBhcyBzdHJpbmcpKSB7XG4gICAgICB0aGlzLmxvZ2dlclNlcnZpY2UubG9nRGVidWcoXG4gICAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICAgICdWYWxpZGF0ZVN0YXRlRnJvbUhhc2hDYWxsYmFjayBmYWlsZWQsIHN0YXRlOiAnICtcbiAgICAgICAgICBzdGF0ZSArXG4gICAgICAgICAgJyBsb2NhbF9zdGF0ZTonICtcbiAgICAgICAgICBsb2NhbFN0YXRlXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpZF90b2tlbiBDNTogVGhlIENsaWVudCBNVVNUIHZhbGlkYXRlIHRoZSBzaWduYXR1cmUgb2YgdGhlIElEIFRva2VuIGFjY29yZGluZyB0byBKV1MgW0pXU10gdXNpbmcgdGhlIGFsZ29yaXRobSBzcGVjaWZpZWQgaW4gdGhlIGFsZ1xuICAvLyBIZWFkZXIgUGFyYW1ldGVyIG9mIHRoZSBKT1NFIEhlYWRlci5UaGUgQ2xpZW50IE1VU1QgdXNlIHRoZSBrZXlzIHByb3ZpZGVkIGJ5IHRoZSBJc3N1ZXIuXG4gIC8vIGlkX3Rva2VuIEM2OiBUaGUgYWxnIHZhbHVlIFNIT1VMRCBiZSBSUzI1Ni4gVmFsaWRhdGlvbiBvZiB0b2tlbnMgdXNpbmcgb3RoZXIgc2lnbmluZyBhbGdvcml0aG1zIGlzIGRlc2NyaWJlZCBpbiB0aGVcbiAgLy8gT3BlbklEIENvbm5lY3QgQ29yZSAxLjAgW09wZW5JRC5Db3JlXSBzcGVjaWZpY2F0aW9uLlxuICB2YWxpZGF0ZVNpZ25hdHVyZUlkVG9rZW4oXG4gICAgaWRUb2tlbjogc3RyaW5nLFxuICAgIGp3dGtleXM6IGFueSxcbiAgICBjb25maWd1cmF0aW9uOiBPcGVuSWRDb25maWd1cmF0aW9uXG4gICk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIGlmICghaWRUb2tlbikge1xuICAgICAgcmV0dXJuIG9mKHRydWUpO1xuICAgIH1cblxuICAgIGlmICghand0a2V5cyB8fCAhand0a2V5cy5rZXlzKSB7XG4gICAgICByZXR1cm4gb2YoZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlckRhdGEgPSB0aGlzLnRva2VuSGVscGVyU2VydmljZS5nZXRIZWFkZXJGcm9tVG9rZW4oXG4gICAgICBpZFRva2VuLFxuICAgICAgZmFsc2UsXG4gICAgICBjb25maWd1cmF0aW9uXG4gICAgKTtcblxuICAgIGlmIChcbiAgICAgIE9iamVjdC5rZXlzKGhlYWRlckRhdGEpLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgaGVhZGVyRGF0YS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XG4gICAgKSB7XG4gICAgICB0aGlzLmxvZ2dlclNlcnZpY2UubG9nV2FybmluZyhcbiAgICAgICAgY29uZmlndXJhdGlvbixcbiAgICAgICAgJ2lkIHRva2VuIGhhcyBubyBoZWFkZXIgZGF0YSdcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBvZihmYWxzZSk7XG4gICAgfVxuXG4gICAgY29uc3Qga2lkOiBzdHJpbmcgPSBoZWFkZXJEYXRhLmtpZDtcbiAgICBjb25zdCBhbGc6IHN0cmluZyA9IGhlYWRlckRhdGEuYWxnO1xuXG4gICAgY29uc3Qga2V5czogSnNvbldlYktleVtdID0gand0a2V5cy5rZXlzO1xuICAgIGxldCBmb3VuZEtleXM6IEpzb25XZWJLZXlbXTtcbiAgICBsZXQga2V5OiBKc29uV2ViS2V5O1xuXG4gICAgaWYgKCF0aGlzLmtleUFsZ29yaXRobXMuaW5jbHVkZXMoYWxnKSkge1xuICAgICAgdGhpcy5sb2dnZXJTZXJ2aWNlLmxvZ1dhcm5pbmcoY29uZmlndXJhdGlvbiwgJ2FsZyBub3Qgc3VwcG9ydGVkJywgYWxnKTtcblxuICAgICAgcmV0dXJuIG9mKGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBrdHkgPSBhbGcya3R5KGFsZyk7XG4gICAgY29uc3QgdXNlID0gJ3NpZyc7XG5cbiAgICB0cnkge1xuICAgICAgZm91bmRLZXlzID0ga2lkXG4gICAgICAgID8gdGhpcy5qd2tFeHRyYWN0b3IuZXh0cmFjdEp3ayhrZXlzLCB7IGtpZCwga3R5LCB1c2UgfSwgZmFsc2UpXG4gICAgICAgIDogdGhpcy5qd2tFeHRyYWN0b3IuZXh0cmFjdEp3ayhrZXlzLCB7IGt0eSwgdXNlIH0sIGZhbHNlKTtcblxuICAgICAgaWYgKGZvdW5kS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm91bmRLZXlzID0ga2lkXG4gICAgICAgICAgPyB0aGlzLmp3a0V4dHJhY3Rvci5leHRyYWN0SndrKGtleXMsIHsga2lkLCBrdHkgfSlcbiAgICAgICAgICA6IHRoaXMuandrRXh0cmFjdG9yLmV4dHJhY3RKd2soa2V5cywgeyBrdHkgfSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGZvdW5kS2V5c1swXTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIHRoaXMubG9nZ2VyU2VydmljZS5sb2dFcnJvcihjb25maWd1cmF0aW9uLCBlKTtcblxuICAgICAgcmV0dXJuIG9mKGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbGdvcml0aG0gPSBnZXRJbXBvcnRBbGcoYWxnKTtcblxuICAgIGNvbnN0IHNpZ25pbmdJbnB1dCA9IHRoaXMudG9rZW5IZWxwZXJTZXJ2aWNlLmdldFNpZ25pbmdJbnB1dEZyb21Ub2tlbihcbiAgICAgIGlkVG9rZW4sXG4gICAgICB0cnVlLFxuICAgICAgY29uZmlndXJhdGlvblxuICAgICk7XG4gICAgY29uc3QgcmF3U2lnbmF0dXJlID0gdGhpcy50b2tlbkhlbHBlclNlcnZpY2UuZ2V0U2lnbmF0dXJlRnJvbVRva2VuKFxuICAgICAgaWRUb2tlbixcbiAgICAgIHRydWUsXG4gICAgICBjb25maWd1cmF0aW9uXG4gICAgKTtcblxuICAgIHJldHVybiBmcm9tKFxuICAgICAgdGhpcy5qd2tXaW5kb3dDcnlwdG9TZXJ2aWNlLmltcG9ydFZlcmlmaWNhdGlvbktleShrZXksIGFsZ29yaXRobSlcbiAgICApLnBpcGUoXG4gICAgICBtZXJnZU1hcCgoY3J5cHRvS2V5OiBDcnlwdG9LZXkpID0+IHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlOiBVaW50OEFycmF5ID0gYmFzZTY0dXJsLnBhcnNlKHJhd1NpZ25hdHVyZSwge1xuICAgICAgICAgIGxvb3NlOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB2ZXJpZnlBbGdvcml0aG0gPSBnZXRWZXJpZnlBbGcoYWxnKTtcblxuICAgICAgICByZXR1cm4gZnJvbShcbiAgICAgICAgICB0aGlzLmp3a1dpbmRvd0NyeXB0b1NlcnZpY2UudmVyaWZ5S2V5KFxuICAgICAgICAgICAgdmVyaWZ5QWxnb3JpdGhtLFxuICAgICAgICAgICAgY3J5cHRvS2V5LFxuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgc2lnbmluZ0lucHV0XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSksXG4gICAgICB0YXAoKGlzVmFsaWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXJTZXJ2aWNlLmxvZ1dhcm5pbmcoXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgJ2luY29ycmVjdCBTaWduYXR1cmUsIHZhbGlkYXRpb24gZmFpbGVkIGZvciBpZF90b2tlbidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvLyBBY2NlcHRzIElEIFRva2VuIHdpdGhvdXQgJ2tpZCcgY2xhaW0gaW4gSk9TRSBoZWFkZXIgaWYgb25seSBvbmUgSldLIHN1cHBsaWVkIGluICdqd2tzX3VybCdcbiAgLy8vLyBwcml2YXRlIHZhbGlkYXRlX25vX2tpZF9pbl9oZWFkZXJfb25seV9vbmVfYWxsb3dlZF9pbl9qd3RrZXlzKGhlYWRlcl9kYXRhOiBhbnksIGp3dGtleXM6IGFueSk6IGJvb2xlYW4ge1xuICAvLy8vICAgIHRoaXMub2lkY1NlY3VyaXR5Q29tbW9uLmxvZ0RlYnVnKCdhbW91bnQgb2Ygand0a2V5cy5rZXlzOiAnICsgand0a2V5cy5rZXlzLmxlbmd0aCk7XG4gIC8vLy8gICAgaWYgKCFoZWFkZXJfZGF0YS5oYXNPd25Qcm9wZXJ0eSgna2lkJykpIHtcbiAgLy8vLyAgICAgICAgLy8gbm8ga2lkIGRlZmluZWQgaW4gSm9zZSBoZWFkZXJcbiAgLy8vLyAgICAgICAgaWYgKGp3dGtleXMua2V5cy5sZW5ndGggIT0gMSkge1xuICAvLy8vICAgICAgICAgICAgdGhpcy5vaWRjU2VjdXJpdHlDb21tb24ubG9nRGVidWcoJ2p3dGtleXMua2V5cy5sZW5ndGggIT0gMSBhbmQgbm8ga2lkIGluIGhlYWRlcicpO1xuICAvLy8vICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAvLy8vICAgICAgICB9XG4gIC8vLy8gICAgfVxuXG4gIC8vLy8gICAgcmV0dXJuIHRydWU7XG4gIC8vLy8gfVxuXG4gIC8vIEFjY2VzcyBUb2tlbiBWYWxpZGF0aW9uXG4gIC8vIGFjY2Vzc190b2tlbiBDMTogSGFzaCB0aGUgb2N0ZXRzIG9mIHRoZSBBU0NJSSByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWNjZXNzX3Rva2VuIHdpdGggdGhlIGhhc2ggYWxnb3JpdGhtIHNwZWNpZmllZCBpbiBKV0FbSldBXVxuICAvLyBmb3IgdGhlIGFsZyBIZWFkZXIgUGFyYW1ldGVyIG9mIHRoZSBJRCBUb2tlbidzIEpPU0UgSGVhZGVyLiBGb3IgaW5zdGFuY2UsIGlmIHRoZSBhbGcgaXMgUlMyNTYsIHRoZSBoYXNoIGFsZ29yaXRobSB1c2VkIGlzIFNIQS0yNTYuXG4gIC8vIGFjY2Vzc190b2tlbiBDMjogVGFrZSB0aGUgbGVmdC0gbW9zdCBoYWxmIG9mIHRoZSBoYXNoIGFuZCBiYXNlNjR1cmwtIGVuY29kZSBpdC5cbiAgLy8gYWNjZXNzX3Rva2VuIEMzOiBUaGUgdmFsdWUgb2YgYXRfaGFzaCBpbiB0aGUgSUQgVG9rZW4gTVVTVCBtYXRjaCB0aGUgdmFsdWUgcHJvZHVjZWQgaW4gdGhlIHByZXZpb3VzIHN0ZXAgaWYgYXRfaGFzaFxuICAvLyBpcyBwcmVzZW50IGluIHRoZSBJRCBUb2tlbi5cbiAgdmFsaWRhdGVJZFRva2VuQXRIYXNoKFxuICAgIGFjY2Vzc1Rva2VuOiBzdHJpbmcsXG4gICAgYXRIYXNoOiBzdHJpbmcsXG4gICAgaWRUb2tlbkFsZzogc3RyaW5nLFxuICAgIGNvbmZpZ3VyYXRpb246IE9wZW5JZENvbmZpZ3VyYXRpb25cbiAgKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgdGhpcy5sb2dnZXJTZXJ2aWNlLmxvZ0RlYnVnKFxuICAgICAgY29uZmlndXJhdGlvbixcbiAgICAgICdhdF9oYXNoIGZyb20gdGhlIHNlcnZlcjonICsgYXRIYXNoXG4gICAgKTtcblxuICAgIC8vICdzaGEyNTYnICdzaGEzODQnICdzaGE1MTInXG4gICAgbGV0IHNoYSA9ICdTSEEtMjU2JztcblxuICAgIGlmIChpZFRva2VuQWxnLmluY2x1ZGVzKCczODQnKSkge1xuICAgICAgc2hhID0gJ1NIQS0zODQnO1xuICAgIH0gZWxzZSBpZiAoaWRUb2tlbkFsZy5pbmNsdWRlcygnNTEyJykpIHtcbiAgICAgIHNoYSA9ICdTSEEtNTEyJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5qd3RXaW5kb3dDcnlwdG9TZXJ2aWNlXG4gICAgICAuZ2VuZXJhdGVBdEhhc2goJycgKyBhY2Nlc3NUb2tlbiwgc2hhKVxuICAgICAgLnBpcGUoXG4gICAgICAgIG1lcmdlTWFwKChoYXNoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICB0aGlzLmxvZ2dlclNlcnZpY2UubG9nRGVidWcoXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgJ2F0X2hhc2ggY2xpZW50IHZhbGlkYXRpb24gbm90IGRlY29kZWQ6JyArIGhhc2hcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChoYXNoID09PSBhdEhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBvZih0cnVlKTsgLy8gaXNWYWxpZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuand0V2luZG93Q3J5cHRvU2VydmljZVxuICAgICAgICAgICAgICAuZ2VuZXJhdGVBdEhhc2goJycgKyBkZWNvZGVVUklDb21wb25lbnQoYWNjZXNzVG9rZW4pLCBzaGEpXG4gICAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIG1hcCgobmV3SGFzaDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlclNlcnZpY2UubG9nRGVidWcoXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICctZ2VuIGFjY2Vzcy0tJyArIGhhc2hcbiAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdIYXNoID09PSBhdEhhc2g7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBtaWxsaXNUb01pbnV0ZXNBbmRTZWNvbmRzKG1pbGxpczogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihtaWxsaXMgLyA2MDAwMCk7XG4gICAgY29uc3Qgc2Vjb25kcyA9ICgobWlsbGlzICUgNjAwMDApIC8gMTAwMCkudG9GaXhlZCgwKTtcblxuICAgIHJldHVybiBtaW51dGVzICsgJzonICsgKCtzZWNvbmRzIDwgMTAgPyAnMCcgOiAnJykgKyBzZWNvbmRzO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVOb3dXaXRoT2Zmc2V0KG9mZnNldFNlY29uZHM6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKSkudmFsdWVPZigpICsgb2Zmc2V0U2Vjb25kcyAqIDEwMDA7XG4gIH1cbn1cbiJdfQ==