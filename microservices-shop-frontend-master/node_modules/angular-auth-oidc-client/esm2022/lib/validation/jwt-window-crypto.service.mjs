import { inject, Injectable } from '@angular/core';
import { from } from 'rxjs';
import { map } from 'rxjs/operators';
import { CryptoService } from '../utils/crypto/crypto.service';
import * as i0 from "@angular/core";
export class JwtWindowCryptoService {
    constructor() {
        this.cryptoService = inject(CryptoService);
    }
    generateCodeChallenge(codeVerifier) {
        return this.calcHash(codeVerifier).pipe(map((challengeRaw) => this.base64UrlEncode(challengeRaw)));
    }
    generateAtHash(accessToken, algorithm) {
        return this.calcHash(accessToken, algorithm).pipe(map((tokenHash) => {
            const substr = tokenHash.substr(0, tokenHash.length / 2);
            const tokenHashBase64 = btoa(substr);
            return tokenHashBase64
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }));
    }
    calcHash(valueToHash, algorithm = 'SHA-256') {
        const msgBuffer = new TextEncoder().encode(valueToHash);
        return from(this.cryptoService.getCrypto().subtle.digest(algorithm, msgBuffer)).pipe(map((hashBuffer) => {
            const buffer = hashBuffer;
            const hashArray = Array.from(new Uint8Array(buffer));
            return this.toHashString(hashArray);
        }));
    }
    toHashString(byteArray) {
        let result = '';
        for (const e of byteArray) {
            result += String.fromCharCode(e);
        }
        return result;
    }
    base64UrlEncode(str) {
        const base64 = btoa(str);
        return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: JwtWindowCryptoService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: JwtWindowCryptoService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: JwtWindowCryptoService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiand0LXdpbmRvdy1jcnlwdG8uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItYXV0aC1vaWRjLWNsaWVudC9zcmMvbGliL3ZhbGlkYXRpb24vand0LXdpbmRvdy1jcnlwdG8uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsSUFBSSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7O0FBRy9ELE1BQU0sT0FBTyxzQkFBc0I7SUFEbkM7UUFFbUIsa0JBQWEsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7S0F1RHhEO0lBckRDLHFCQUFxQixDQUFDLFlBQW9CO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQ3JDLEdBQUcsQ0FBQyxDQUFDLFlBQW9CLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FDbEUsQ0FBQztJQUNKLENBQUM7SUFFRCxjQUFjLENBQUMsV0FBbUIsRUFBRSxTQUFpQjtRQUNuRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FDL0MsR0FBRyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7WUFDaEIsTUFBTSxNQUFNLEdBQVcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNqRSxNQUFNLGVBQWUsR0FBVyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFN0MsT0FBTyxlQUFlO2lCQUNuQixPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQztpQkFDbkIsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7aUJBQ25CLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDdkIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFTyxRQUFRLENBQ2QsV0FBbUIsRUFDbkIsU0FBUyxHQUFHLFNBQVM7UUFFckIsTUFBTSxTQUFTLEdBQWUsSUFBSSxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFcEUsT0FBTyxJQUFJLENBQ1QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FDbkUsQ0FBQyxJQUFJLENBQ0osR0FBRyxDQUFDLENBQUMsVUFBbUIsRUFBRSxFQUFFO1lBQzFCLE1BQU0sTUFBTSxHQUFHLFVBQXlCLENBQUM7WUFDekMsTUFBTSxTQUFTLEdBQWEsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBRS9ELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN0QyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQztJQUVPLFlBQVksQ0FBQyxTQUFtQjtRQUN0QyxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFFaEIsS0FBSyxNQUFNLENBQUMsSUFBSSxTQUFTLEVBQUU7WUFDekIsTUFBTSxJQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDbEM7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRU8sZUFBZSxDQUFDLEdBQVc7UUFDakMsTUFBTSxNQUFNLEdBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWpDLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzFFLENBQUM7OEdBdkRVLHNCQUFzQjtrSEFBdEIsc0JBQXNCLGNBRFQsTUFBTTs7MkZBQ25CLHNCQUFzQjtrQkFEbEMsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb20sIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENyeXB0b1NlcnZpY2UgfSBmcm9tICcuLi91dGlscy9jcnlwdG8vY3J5cHRvLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEp3dFdpbmRvd0NyeXB0b1NlcnZpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGNyeXB0b1NlcnZpY2UgPSBpbmplY3QoQ3J5cHRvU2VydmljZSk7XG5cbiAgZ2VuZXJhdGVDb2RlQ2hhbGxlbmdlKGNvZGVWZXJpZmllcjogc3RyaW5nKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5jYWxjSGFzaChjb2RlVmVyaWZpZXIpLnBpcGUoXG4gICAgICBtYXAoKGNoYWxsZW5nZVJhdzogc3RyaW5nKSA9PiB0aGlzLmJhc2U2NFVybEVuY29kZShjaGFsbGVuZ2VSYXcpKVxuICAgICk7XG4gIH1cblxuICBnZW5lcmF0ZUF0SGFzaChhY2Nlc3NUb2tlbjogc3RyaW5nLCBhbGdvcml0aG06IHN0cmluZyk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuY2FsY0hhc2goYWNjZXNzVG9rZW4sIGFsZ29yaXRobSkucGlwZShcbiAgICAgIG1hcCgodG9rZW5IYXNoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnN0cjogc3RyaW5nID0gdG9rZW5IYXNoLnN1YnN0cigwLCB0b2tlbkhhc2gubGVuZ3RoIC8gMik7XG4gICAgICAgIGNvbnN0IHRva2VuSGFzaEJhc2U2NDogc3RyaW5nID0gYnRvYShzdWJzdHIpO1xuXG4gICAgICAgIHJldHVybiB0b2tlbkhhc2hCYXNlNjRcbiAgICAgICAgICAucmVwbGFjZSgvXFwrL2csICctJylcbiAgICAgICAgICAucmVwbGFjZSgvXFwvL2csICdfJylcbiAgICAgICAgICAucmVwbGFjZSgvPS9nLCAnJyk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGNhbGNIYXNoKFxuICAgIHZhbHVlVG9IYXNoOiBzdHJpbmcsXG4gICAgYWxnb3JpdGhtID0gJ1NIQS0yNTYnXG4gICk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG4gICAgY29uc3QgbXNnQnVmZmVyOiBVaW50OEFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlVG9IYXNoKTtcblxuICAgIHJldHVybiBmcm9tKFxuICAgICAgdGhpcy5jcnlwdG9TZXJ2aWNlLmdldENyeXB0bygpLnN1YnRsZS5kaWdlc3QoYWxnb3JpdGhtLCBtc2dCdWZmZXIpXG4gICAgKS5waXBlKFxuICAgICAgbWFwKChoYXNoQnVmZmVyOiB1bmtub3duKSA9PiB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGhhc2hCdWZmZXIgYXMgQXJyYXlCdWZmZXI7XG4gICAgICAgIGNvbnN0IGhhc2hBcnJheTogbnVtYmVyW10gPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRvSGFzaFN0cmluZyhoYXNoQXJyYXkpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSB0b0hhc2hTdHJpbmcoYnl0ZUFycmF5OiBudW1iZXJbXSk6IHN0cmluZyB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gICAgZm9yIChjb25zdCBlIG9mIGJ5dGVBcnJheSkge1xuICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgYmFzZTY0VXJsRW5jb2RlKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBiYXNlNjQ6IHN0cmluZyA9IGJ0b2Eoc3RyKTtcblxuICAgIHJldHVybiBiYXNlNjQucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvPS9nLCAnJyk7XG4gIH1cbn1cbiJdfQ==