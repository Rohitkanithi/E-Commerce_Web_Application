import { DOCUMENT } from '@angular/common';
import { Injectable, inject } from '@angular/core';
import { LoggerService } from '../../logging/logger.service';
import * as i0 from "@angular/core";
const PARTS_OF_TOKEN = 3;
export class TokenHelperService {
    constructor() {
        this.loggerService = inject(LoggerService);
        this.document = inject(DOCUMENT);
    }
    getTokenExpirationDate(dataIdToken) {
        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'exp')) {
            return new Date(new Date().toUTCString());
        }
        const date = new Date(0); // The 0 here is the key, which sets the date to the epoch
        date.setUTCSeconds(dataIdToken.exp);
        return date;
    }
    getSigningInputFromToken(token, encoded, configuration) {
        if (!this.tokenIsValid(token, configuration)) {
            return '';
        }
        const header = this.getHeaderFromToken(token, encoded, configuration);
        const payload = this.getPayloadFromToken(token, encoded, configuration);
        return [header, payload].join('.');
    }
    getHeaderFromToken(token, encoded, configuration) {
        if (!this.tokenIsValid(token, configuration)) {
            return {};
        }
        return this.getPartOfToken(token, 0, encoded);
    }
    getPayloadFromToken(token, encoded, configuration) {
        if (!configuration) {
            return {};
        }
        if (!this.tokenIsValid(token, configuration)) {
            return {};
        }
        return this.getPartOfToken(token, 1, encoded);
    }
    getSignatureFromToken(token, encoded, configuration) {
        if (!this.tokenIsValid(token, configuration)) {
            return {};
        }
        return this.getPartOfToken(token, 2, encoded);
    }
    getPartOfToken(token, index, encoded) {
        const partOfToken = this.extractPartOfToken(token, index);
        if (encoded) {
            return partOfToken;
        }
        const result = this.urlBase64Decode(partOfToken);
        return JSON.parse(result);
    }
    urlBase64Decode(str) {
        let output = str.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0:
                break;
            case 2:
                output += '==';
                break;
            case 3:
                output += '=';
                break;
            default:
                throw Error('Illegal base64url string!');
        }
        const decoded = typeof this.document.defaultView !== 'undefined'
            ? this.document.defaultView?.atob(output)
            : Buffer.from(output, 'base64').toString('binary');
        if (!decoded) {
            return '';
        }
        try {
            // Going backwards: from byte stream, to percent-encoding, to original string.
            return decodeURIComponent(decoded
                .split('')
                .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
                .join(''));
        }
        catch (err) {
            return decoded;
        }
    }
    tokenIsValid(token, configuration) {
        if (!token) {
            this.loggerService.logError(configuration, `token '${token}' is not valid --> token falsy`);
            return false;
        }
        if (!token.includes('.')) {
            this.loggerService.logError(configuration, `token '${token}' is not valid --> no dots included`);
            return false;
        }
        const parts = token.split('.');
        if (parts.length !== PARTS_OF_TOKEN) {
            this.loggerService.logError(configuration, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);
            return false;
        }
        return true;
    }
    extractPartOfToken(token, index) {
        return token.split('.')[index];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: TokenHelperService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: TokenHelperService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.8", ngImport: i0, type: TokenHelperService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW4taGVscGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWF1dGgtb2lkYy1jbGllbnQvc3JjL2xpYi91dGlscy90b2tlbkhlbHBlci90b2tlbi1oZWxwZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDhCQUE4QixDQUFDOztBQUU3RCxNQUFNLGNBQWMsR0FBRyxDQUFDLENBQUM7QUFHekIsTUFBTSxPQUFPLGtCQUFrQjtJQUQvQjtRQUVtQixrQkFBYSxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUV0QyxhQUFRLEdBQUcsTUFBTSxDQUFXLFFBQVEsQ0FBQyxDQUFDO0tBMEt4RDtJQXhLQyxzQkFBc0IsQ0FBQyxXQUFnQjtRQUNyQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsRUFBRTtZQUM3RCxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztTQUMzQztRQUVELE1BQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsMERBQTBEO1FBRXBGLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXBDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELHdCQUF3QixDQUN0QixLQUE0QixFQUM1QixPQUFnQixFQUNoQixhQUFrQztRQUVsQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVB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QUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFTyxrQkFBa0IsQ0FBQyxLQUFhLEVBQUUsS0FBYTtRQUNyRCxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakMsQ0FBQzs4R0E1S1Usa0JBQWtCO2tIQUFsQixrQkFBa0IsY0FETCxNQUFNOzsyRkFDbkIsa0JBQWtCO2tCQUQ5QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEluamVjdGFibGUsIGluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT3BlbklkQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uLy4uL2NvbmZpZy9vcGVuaWQtY29uZmlndXJhdGlvbic7XG5pbXBvcnQgeyBMb2dnZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vbG9nZ2luZy9sb2dnZXIuc2VydmljZSc7XG5cbmNvbnN0IFBBUlRTX09GX1RPS0VOID0gMztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBUb2tlbkhlbHBlclNlcnZpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlclNlcnZpY2UgPSBpbmplY3QoTG9nZ2VyU2VydmljZSk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBkb2N1bWVudCA9IGluamVjdDxEb2N1bWVudD4oRE9DVU1FTlQpO1xuXG4gIGdldFRva2VuRXhwaXJhdGlvbkRhdGUoZGF0YUlkVG9rZW46IGFueSk6IERhdGUge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFJZFRva2VuLCAnZXhwJykpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnRvVVRDU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgwKTsgLy8gVGhlIDAgaGVyZSBpcyB0aGUga2V5LCB3aGljaCBzZXRzIHRoZSBkYXRlIHRvIHRoZSBlcG9jaFxuXG4gICAgZGF0ZS5zZXRVVENTZWNvbmRzKGRhdGFJZFRva2VuLmV4cCk7XG5cbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGdldFNpZ25pbmdJbnB1dEZyb21Ub2tlbihcbiAgICB0b2tlbjogc3RyaW5nfHVuZGVmaW5lZHxudWxsLFxuICAgIGVuY29kZWQ6IGJvb2xlYW4sXG4gICAgY29uZmlndXJhdGlvbjogT3BlbklkQ29uZmlndXJhdGlvblxuICApOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy50b2tlbklzVmFsaWQodG9rZW4sIGNvbmZpZ3VyYXRpb24pKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGVyOiBzdHJpbmcgPSB0aGlzLmdldEhlYWRlckZyb21Ub2tlbihcbiAgICAgIHRva2VuLFxuICAgICAgZW5jb2RlZCxcbiAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICApO1xuICAgIGNvbnN0IHBheWxvYWQ6IHN0cmluZyA9IHRoaXMuZ2V0UGF5bG9hZEZyb21Ub2tlbihcbiAgICAgIHRva2VuLFxuICAgICAgZW5jb2RlZCxcbiAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICApO1xuXG4gICAgcmV0dXJuIFtoZWFkZXIsIHBheWxvYWRdLmpvaW4oJy4nKTtcbiAgfVxuXG4gIGdldEhlYWRlckZyb21Ub2tlbihcbiAgICB0b2tlbjogc3RyaW5nfHVuZGVmaW5lZHxudWxsLFxuICAgIGVuY29kZWQ6IGJvb2xlYW4sXG4gICAgY29uZmlndXJhdGlvbjogT3BlbklkQ29uZmlndXJhdGlvblxuICApOiBhbnkge1xuICAgIGlmICghdGhpcy50b2tlbklzVmFsaWQodG9rZW4sIGNvbmZpZ3VyYXRpb24pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFydE9mVG9rZW4odG9rZW4sIDAsIGVuY29kZWQpO1xuICB9XG5cbiAgZ2V0UGF5bG9hZEZyb21Ub2tlbihcbiAgICB0b2tlbjogc3RyaW5nfHVuZGVmaW5lZHxudWxsLFxuICAgIGVuY29kZWQ6IGJvb2xlYW4sXG4gICAgY29uZmlndXJhdGlvbjogT3BlbklkQ29uZmlndXJhdGlvbiB8IG51bGxcbiAgKTogYW55IHtcbiAgICBpZiAoIWNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudG9rZW5Jc1ZhbGlkKHRva2VuLCBjb25maWd1cmF0aW9uKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldFBhcnRPZlRva2VuKHRva2VuLCAxLCBlbmNvZGVkKTtcbiAgfVxuXG4gIGdldFNpZ25hdHVyZUZyb21Ub2tlbihcbiAgICB0b2tlbjogc3RyaW5nfHVuZGVmaW5lZHxudWxsLFxuICAgIGVuY29kZWQ6IGJvb2xlYW4sXG4gICAgY29uZmlndXJhdGlvbjogT3BlbklkQ29uZmlndXJhdGlvblxuICApOiBhbnkge1xuICAgIGlmICghdGhpcy50b2tlbklzVmFsaWQodG9rZW4sIGNvbmZpZ3VyYXRpb24pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFydE9mVG9rZW4odG9rZW4sIDIsIGVuY29kZWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRQYXJ0T2ZUb2tlbih0b2tlbjogc3RyaW5nLCBpbmRleDogbnVtYmVyLCBlbmNvZGVkOiBib29sZWFuKTogYW55IHtcbiAgICBjb25zdCBwYXJ0T2ZUb2tlbiA9IHRoaXMuZXh0cmFjdFBhcnRPZlRva2VuKHRva2VuLCBpbmRleCk7XG5cbiAgICBpZiAoZW5jb2RlZCkge1xuICAgICAgcmV0dXJuIHBhcnRPZlRva2VuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudXJsQmFzZTY0RGVjb2RlKHBhcnRPZlRva2VuKTtcblxuICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3VsdCk7XG4gIH1cblxuICBwcml2YXRlIHVybEJhc2U2NERlY29kZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IG91dHB1dCA9IHN0ci5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpO1xuXG4gICAgc3dpdGNoIChvdXRwdXQubGVuZ3RoICUgNCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgb3V0cHV0ICs9ICc9PSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBvdXRwdXQgKz0gJz0nO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9yKCdJbGxlZ2FsIGJhc2U2NHVybCBzdHJpbmchJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2RlZCA9XG4gICAgICB0eXBlb2YgdGhpcy5kb2N1bWVudC5kZWZhdWx0VmlldyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3Py5hdG9iKG91dHB1dClcbiAgICAgICAgOiBCdWZmZXIuZnJvbShvdXRwdXQsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5Jyk7XG5cbiAgICBpZiAoIWRlY29kZWQpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gR29pbmcgYmFja3dhcmRzOiBmcm9tIGJ5dGUgc3RyZWFtLCB0byBwZXJjZW50LWVuY29kaW5nLCB0byBvcmlnaW5hbCBzdHJpbmcuXG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICBkZWNvZGVkXG4gICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAoYzogc3RyaW5nKSA9PiAnJScgKyAoJzAwJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKVxuICAgICAgICAgIClcbiAgICAgICAgICAuam9pbignJylcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRva2VuSXNWYWxpZChcbiAgICB0b2tlbjogc3RyaW5nfHVuZGVmaW5lZHxudWxsLFxuICAgIGNvbmZpZ3VyYXRpb246IE9wZW5JZENvbmZpZ3VyYXRpb25cbiAgKTogdG9rZW4gaXMgc3RyaW5nIHtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aGlzLmxvZ2dlclNlcnZpY2UubG9nRXJyb3IoXG4gICAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICAgIGB0b2tlbiAnJHt0b2tlbn0nIGlzIG5vdCB2YWxpZCAtLT4gdG9rZW4gZmFsc3lgXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEodG9rZW4gYXMgc3RyaW5nKS5pbmNsdWRlcygnLicpKSB7XG4gICAgICB0aGlzLmxvZ2dlclNlcnZpY2UubG9nRXJyb3IoXG4gICAgICAgIGNvbmZpZ3VyYXRpb24sXG4gICAgICAgIGB0b2tlbiAnJHt0b2tlbn0nIGlzIG5vdCB2YWxpZCAtLT4gbm8gZG90cyBpbmNsdWRlZGBcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG5cbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSBQQVJUU19PRl9UT0tFTikge1xuICAgICAgdGhpcy5sb2dnZXJTZXJ2aWNlLmxvZ0Vycm9yKFxuICAgICAgICBjb25maWd1cmF0aW9uLFxuICAgICAgICBgdG9rZW4gJyR7dG9rZW59JyBpcyBub3QgdmFsaWQgLS0+IHRva2VuIGhhcyB0byBoYXZlIGV4YWN0bHkgJHtcbiAgICAgICAgICBQQVJUU19PRl9UT0tFTiAtIDFcbiAgICAgICAgfSBkb3RzYFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0UGFydE9mVG9rZW4odG9rZW46IHN0cmluZywgaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRva2VuLnNwbGl0KCcuJylbaW5kZXhdO1xuICB9XG59XG4iXX0=